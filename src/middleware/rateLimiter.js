/**
 * AI Generated: This file is generated by Claude
 */

import createFixedWindowLimiter from "../algorithms/fixedWindow.js";
import createSlidingWindowLimiter from "../algorithms/slidingWindow.js";
import createTokenBucketLimiter from "../algorithms/tokenBucket.js";
import createSlidingLogLimiter from "../algorithms/slidingLog.js";
import createLeakyBucketLimiter from "../algorithms/leakyBucket.js";

class RateLimiter {
  constructor(config) {
    this.storage = config.storage;
    this.algorithm = config.algorithm;
    this.keyGenerator = config.keyGenerator || ((req) => req.ip);
    this.config = config;

    // Select algorithm implementation
    this.limiter = this.selectAlgorithm(config);
  }

  selectAlgorithm(config) {
    const algorithms = {
      "fixed-window": () => createFixedWindowLimiter(config),
      "sliding-window": () => createSlidingWindowLimiter(config),
      "token-bucket": () => createTokenBucketLimiter(config),
      "sliding-log": () => createSlidingLogLimiter(config),
      "leaky-bucket": () => createLeakyBucketLimiter(config),
    };

    const algorithm = algorithms[config.algorithm];
    if (!algorithm) {
      throw new Error(`Unknown algorithm: ${config.algorithm}`);
    }

    return algorithm();
  }

  async limit(req) {
    const identifier = this.keyGenerator(req);
    return await this.limiter(this.storage, identifier);
  }

  middleware() {
    return async (req, res, next) => {
      try {
        const result = await this.limit(req);

        // Set rate limit headers
        res.setHeader("X-RateLimit-Limit", result.limit);
        res.setHeader("X-RateLimit-Remaining", result.remaining);
        res.setHeader(
          "X-RateLimit-Reset",
          new Date(result.reset).toISOString(),
        );

        if (!result.success) {
          if (result.retryAfter) {
            res.setHeader("Retry-After", result.retryAfter);
          }

          return res.status(429).json({
            error: "Too Many Requests",
            message: "Rate limit exceeded",
            retryAfter: result.retryAfter,
            reset: new Date(result.reset).toISOString(),
          });
        }

        // Store rate limit info for use in route handlers
        res.locals.rateLimit = result;
        next();
      } catch (error) {
        console.error("Rate limiter error:", error);
        // Fail open - allow request if rate limiter fails
        next();
      }
    };
  }
}

export { RateLimiter };
